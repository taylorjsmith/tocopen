\section{Pushdown Automata}\label{sec:pushdownautomata}

\firstwords{When we first introduced} finite automata as a computational model for regular languages, we emphasized the facts that finite automata have no method of storage and no ability to return to a previously read symbol. Naturally, these restrictions limited the kinds of languages the model is able to recognize, and we showed that such restrictions resulted in the model recognizing exactly the class of regular languages.

At the end of the previous lecture, we saw that there exist languages that are not regular, and therefore are not recognized by finite automata. We know now that the next ``step" of our language hierarchy is the class of context-free languages. Thus, a new question arises: what kind of computational model is capable of recognizing context-free languages?

Since every context-free language is generated by a context-free grammar, and since we know that context-free grammars must ``remember" which nonterminal and terminal symbols are being manipulated over the course of a derivation, any model of computation recognizing context-free languages must include a form of memory. What is the best form of memory to use in this situation? If we view a derivation as a parse tree, then the derivation progresses as we go deeper into the parse tree, and we can easily model the depth of a derivation using \emph{stack} memory.

As a brief review, a stack is a data structure with two operations that manipulate data: \emph{push} and \emph{pop}. Pushing a symbol to a stack adds it to the top of the stack, above all other symbols already in the stack. Conversely, popping a symbol from a stack removes it from the top of the stack, leaving all other symbols untouched. (See Figure~\ref{fig:stacks} for an example of pushing and popping.) As a result, a stack provides last-in-first-out, or LIFO, storage---by comparison, a data structure like a queue provides first-in-first-out, or FIFO, storage. We can view the symbol at the top of the stack at any time during a computation, but we cannot view any other symbols in the stack unless we pop the symbol currently at the top of the stack.

\begin{figure}[b]
\centering
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw, anchor=center}]
\node[stack=4] (S) {
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\end{tikzpicture}
\hspace{0cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw=none, anchor=center}]
\node[stack=3]  {
\nodepart{two}$\xRightarrow{\text{push } \texttt{a}}$
};
\end{tikzpicture}
\hspace{0cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,white,white,\fourthcolour}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}{\color{\maincolour}\texttt{a}}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\end{tikzpicture}
\hspace{0cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw=none, anchor=center}]
\node[stack=3]  {
\nodepart{two}$\xRightarrow{\text{push } \texttt{b}}$
};
\end{tikzpicture}
\hspace{0cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,white,\fourthcolour,white}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{three}{\color{\maincolour}\texttt{b}}
\nodepart{four}\texttt{a}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\end{tikzpicture}
\hspace{0cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw=none, anchor=center}]
\node[stack=3]  {
\nodepart{two}$\xRightarrow{\text{pop } \texttt{b}}$
};
\end{tikzpicture}
\hspace{0cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,white,white,\fourthcolour}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}{\color{\maincolour}\texttt{a}}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\end{tikzpicture}
\hspace{0cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw=none, anchor=center}]
\node[stack=3]  {
\nodepart{two}$\xRightarrow{\text{push } \texttt{c}}$
};
\end{tikzpicture}
\hspace{0cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,white,\fourthcolour,white}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{three}{\color{\maincolour}\texttt{c}}
\nodepart{four}\texttt{a}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\end{tikzpicture}
\hspace{0cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw=none, anchor=center}]
\node[stack=3]  {
\nodepart{two}$\xRightarrow{\text{push } \texttt{a}}$
};
\end{tikzpicture}
\hspace{0cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,\fourthcolour,white,white}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{two}{\color{\maincolour}\texttt{a}}
\nodepart{three}\texttt{c}
\nodepart{four}\texttt{a}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\end{tikzpicture}
\caption{Pushing symbols to and popping symbols from a stack. At each step, the currently visible symbol at the top of the stack is highlighted}
\label{fig:stacks}
\end{figure}

Since we're dealing with an abstract model of computation and not a real-world computer, we can make the assumption that our stack size is \emph{unbounded}; that is, we can push as many symbols to the stack as we want without worrying about running out of space.

Now that we have our form of storage established, we can define our model of computation. At its core, this model is a finite automaton with a stack added to it. Since the automaton is now able to push symbols to a stack, we give it an appropriate name: a \emph{pushdown automaton}.

\begin{remark}
The name ``pushdown automaton" doesn't specifically come from its ability to push symbols, but rather from an older term for a stack: a \emph{pushdown store}.
\end{remark}

In addition to reading a symbol of its input word on a transition, a pushdown automaton can read from and write to the stack on the same transition. In order to perform this mixture of input and stack actions, we specify two alphabets for a pushdown automaton: the \emph{input alphabet}, which contains symbols used in the input word, and the \emph{stack alphabet}, which contains symbols the pushdown automaton can use in its stack. This allows us to combine actions on the input word and actions on the stack in a single transition, without risking confusion over the meaning of any particular alphabet symbol. The transitions of a pushdown automaton may additionally use $\epsilon$ in place of either the input word action (i.e., when we don't read a symbol of the input word) or the stack action (i.e., when we don't push to/pop from the stack). Just like we denoted a finite automaton's alphabet by $\Sigma$, we will use $\Sigma$ to denote a pushdown automaton's input alphabet. Likewise, we will use $\Gamma$ to denote the stack alphabet.

In order for our model of computation to use two alphabets at once, we must modify its transition function accordingly. Recall that a finite automaton (with epsilon transitions) transitions on a pair $(q, a)$, where $q \in Q$ and $a \in \Sigma \cup \{\epsilon\}$. By comparison, a pushdown automaton transitions on a tuple $(q, a, b)$, where $q \in Q$, $a \in \Sigma \cup \{\epsilon\}$, and $b \in \Gamma \cup \{\epsilon\}$. Thus, a pushdown automaton uses both the current symbol of its input word (or $\epsilon$) as well as the top symbol of its stack (or $\epsilon$) to determine the state to which it will transition. After transitioning, the pushdown automaton will be in a possibly different state, and it will have a possibly different symbol at the top of its stack.

Lastly, a pushdown automaton has no inherent mechanism for detecting whether its stack is empty. To make our lives easier when it comes to keeping track of the stack contents, we can incorporate a special ``bottom of stack" symbol $\bot$ into the transitions of a pushdown automaton in such a way that $\bot$ is both the first symbol pushed to the stack and the last symbol popped from the stack.

\begin{remark}
We don't require this special symbol, since pushdown automata can accept either by being in a final state or by having an empty stack after reaching the end of its input word. As it turns out, these two methods of acceptance are equivalent, and our approach effectively combines the two.
\end{remark}

Having established all of the technical details, we can now formulate the definition of a pushdown automaton. Since a pushdown automaton is essentially just a finite automaton with a stack, we can start by copying the text from Definition~\ref{def:NFA} and adding to it the necessary components for handling the stack: the stack alphabet, a mechanism for popping symbols (if necessary) from the stack, and a mechanism for pushing symbols (if necessary) to the stack.

\begin{definition}[Pushdown automaton]
A pushdown automaton is a tuple $(Q, \Sigma, \Gamma, \delta, q_{0}, F)$, where
\begin{itemize}
\item $Q$ is a finite set of \emph{states};
\item $\Sigma$ is the \emph{input alphabet};
\item $\Gamma$ is the \emph{stack alphabet};
\item $\delta \from Q \times (\Sigma \cup \{\epsilon\}) \times (\Gamma \cup \{\epsilon\}) \to \mathcal{P}\left(Q \times (\Gamma \cup \{\epsilon\})\right)$ is the \emph{transition function};
\item $q_{0} \in Q$ is the \emph{initial} or \emph{start state}; and
\item $F \subseteq Q$ is the set of \emph{final} or \emph{accepting states}.
\end{itemize}
\end{definition}

\begin{figure}[t]
\centering
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,\fourthcolour,white,white}, draw, anchor=center}]
\node[draw=none, color=black, align=center, font={\small}] at (1,2.5) {Finite \\ automaton};
\draw[draw=black, fill=\fourthcolour] (0,0) rectangle (2,2);
\draw[draw=\secondcolour, fill=\secondcolour] (0.5,1.5) circle (0.2);
\draw[draw=\secondcolour, fill=\secondcolour] (1.4,1) circle (0.2);
\draw[draw=\secondcolour, fill=\secondcolour] (0.6,0.5) circle (0.2);
\draw[-Latex, thick, draw=\secondcolour] (0.52,1.3) -- (0.575,0.7);
\draw[-Latex, thick, draw=\secondcolour] (0.675,1.4) -- (1.225,1.1);
\draw [-Latex, thick, draw=\secondcolour, looseness=4] (1.275,0.85) .. controls (0.9,0.3) and (1.8,0.3) .. (1.525,0.875);

\node[draw=none, color=black, align=center, font={\small}] at (3.5,2.275) {Input word};
\node[draw=none, color=black, font={\large}] at (3.5,1) {\texttt{0101101110}};
\draw[-Latex, thick, draw=\neutralcolour] (4.55,0.7) -- (2.6,0.7);
\node[trapezium, trapezium left angle=70, trapezium right angle=70, draw=black, fill=\fourthcolour, rotate=90, minimum width=0.75cm, minimum height=0.5cm] (t) at (2.25,1) {};

\node[draw=none, color=black, align=center, font={\small}] at (-1.6,2.275) {Stack};
\draw[draw=black, fill=\fourthcolour] (-0.2,0.8) rectangle (0,1.2);
\draw[-Latex, thick, draw=\secondcolour] (-0.2,1) -- (-0.75,1) -- (-0.75,1.275) -- (-1.375,1.275);

\node[stack=4] (S) at (-1.6,1) {
\nodepart{two}{\color{\maincolour}\texttt{a}}
\nodepart{three}\texttt{b}
\nodepart{four}$\bot$
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\end{tikzpicture}
\caption{An illustration of a pushdown automaton}
\label{fig:pushdownautomaton}
\end{figure}

\noindent
Figure~\ref{fig:pushdownautomaton} illustrates how we might visualize a pushdown automaton. Observe that our definition doesn't mention the ``bottom of stack" symbol $\bot$, since it isn't strictly necessary. However, since we will use it to aid in our understanding, we will assume that $\bot \in \Gamma$ and that $\bot$ is not used in any transition of $\delta$ except for those exiting $q_{0}$ and those entering any final state.

\begin{remark}
Here is another moment for grammatical pedantry. Just like the distinction between the singular ``finite automat\underline{on}" and the plural ``finite automat\underline{a}", it is never correct to write something like ``\underline{a} pushdown automat\underline{a}" in reference to a single instance of such a model.
\end{remark}

\begin{example}
Consider a pushdown automaton $\mathcal{M}$ where $Q = \{q_{0}, q_{1}, q_{2}, q_{3}\}$, $\Sigma = \{\texttt{a}, \texttt{b}\}$, $\Gamma = \{\bot, \texttt{A}\}$, $q_{0} = q_{0}$, $F = \{q_{3}\}$, and $\delta$ is defined as follows:
\begin{center}
\small
\begin{tabular}{c | c c c | c c c | c c c}
$\Sigma$:		& \multicolumn{3}{c}{\texttt{a}}	& \multicolumn{3}{c}{\texttt{b}}	& \multicolumn{3}{c}{$\epsilon$} \\
\hline
$\Gamma$:	& $\bot$ 		& \texttt{A}	& $\epsilon$			& $\bot$ 		& \texttt{A}			& $\epsilon$	& $\bot$ 				& \texttt{A}	& $\epsilon$ \\
\hline
$q_{0}$		& ---			& ---			& ---					& ---			& ---					& ---			& ---					& ---			& $\{(q_{1}, \bot)\}$ \\
$q_{1}$		& ---			& ---			& $\{(q_{1}, \texttt{A})\}$	& ---			& $\{(q_{2}, \epsilon)\}$	& ---			& ---					& ---			& --- \\
$q_{2}$		& ---			& ---			& ---					& ---			& $\{(q_{2}, \epsilon)\}$	& ---			& $\{(q_{3}, \epsilon)\}$	& ---			& --- \\
$q_{3}$		& ---			& ---			& ---					& ---			& ---					& ---			& ---					& ---			& --- 
\end{tabular}
\end{center}
In the transition function table, the top row indicates the input symbol being read and the second-from-top row indicates the symbol to be popped from the stack. Each entry of the table is an ordered pair where the first element is the state being transitioned to and the second element is the symbol being pushed to the stack.

The pushdown automaton $\mathcal{M}$ can be represented visually as follows:
\begin{center}
\begin{tikzpicture}[node distance=2.5cm, >=latex, every state/.style={fill=white}]
\node[state, initial] (q0) {$q_{0}$};
\node[state] (q1) [right of=q0] {$q_{1}$};
\node[state] (q2) [right of=q1] {$q_{2}$};
\node[state, accepting] (q3) [right of=q2] {$q_{3}$};

\path[-latex] (q0) edge [above] node {$\epsilon, \epsilon \mapsto \bot$} (q1);
\path[-latex] (q1) edge [loop above] node {$\texttt{a}, \epsilon \mapsto \texttt{A}$} (q1);
\path[-latex] (q1) edge [above] node {$\texttt{b}, \texttt{A} \mapsto \epsilon$} (q2);
\path[-latex] (q2) edge [loop above] node {$\texttt{b}, \texttt{A} \mapsto \epsilon$} (q2);
\path[-latex] (q2) edge [above] node {$\epsilon, \bot \mapsto \epsilon$} (q3);
\end{tikzpicture}
\end{center}
Notice that each transition has a label of the form $a, B \mapsto C$; this means that, upon reading an input symbol $a$ and popping a symbol $B$ from the stack, the pushdown automaton pushes a symbol $C$ to the stack.

Between states $q_{0}$ and $q_{1}$, the pushdown automaton pushes the symbol $\bot$ to the stack to mark the bottom. In state $q_{1}$, the pushdown automaton reads some number of \texttt{a}s and pushes the same number of \texttt{A}s to the stack. Between states $q_{1}$ and $q_{2}$, as well as in state $q_{2}$, the pushdown automaton reads some number of \texttt{b}s and pops the same number of \texttt{A}s from the stack. Finally, between states $q_{2}$ and $q_{3}$, the pushdown automaton pops $\bot$ from the stack only if there are no more input symbols to read and no more stack symbols to process.

After some observation, we can see that our pushdown automaton accepts all input words of the form $\texttt{a}^{n}\texttt{b}^{n}$ where $n \geq 1$.
\end{example}

You may have noticed in our definition that the transition function maps to the power set of state/stack symbol pairs, which makes the pushdown automaton nondeterministic. This was not done by mistake. Unlike finite automata, where the deterministic and nondeterministic models are equivalent in terms of recognition power, deterministic pushdown automata actually recognize \emph{fewer} languages than nondeterministic pushdown automata. In the interest of full generality, then, we take all of our pushdown automata to be nondeterministic, even if we don't need to use nondeterminism.

\subsection{Computations and Accepting Computations}

Let us now consider precisely what it means for a pushdown automaton to accept an input word. As we had with finite automata, one of the main conditions for acceptance is that there exists some sequence of states through the automaton where it begins reading its input word in an initial state and finishes reading in an accepting state. Since pushdown automata also come with a stack, though, we must account for the contents of the stack over the course of the computation. Specifically, we assume that the stack is empty at the beginning of the computation and, on each transition, the pushdown automaton can modify the top symbol of its stack appropriately.

\begin{definition}[Accepting computation of a pushdown automaton]
Let $\mathcal{M} = (Q, \Sigma, \Gamma, \delta, q_{0}, F)$ be a pushdown automaton, and let $w = w_{0} w_{1} \dots w_{n-1}$ be an input word of length $n$ where $w_{0}, w_{1}, \dots, w_{n - 1} \in \Sigma$. The pushdown automaton $\mathcal{M}$ accepts the input word $w$ if there exists a sequence of states $r_{0}, r_{1}, \dots, r_{n} \in Q$ and a sequence of stack contents $s_{0}, s_{1}, \dots, s_{n} \in \Gamma^{*}$ satisfying the following conditions:
\begin{enumerate}
\item $r_{0} = q_{0}$ and $s_{0} = \epsilon$;
\item $(r_{i+1}, b') \in \delta(r_{i}, w_{i}, b)$ for all $0 \leq i \leq (n-1)$, where $s_{i} = bt$ and $s_{i+1} = b't$ for some $b, b' \in \Gamma \cup \{\epsilon\}$ and $t \in \Gamma^{*}$; and
\item $r_{n} \in F$.
\end{enumerate}
\end{definition}

The second condition is rather notation-heavy, but the underlying idea describes exactly how a pushdown automaton transitions between states: starting in a state $r_{i}$ with a symbol $b$ at the top of the stack, the pushdown automaton reads an input symbol $w_{i}$ and pops the symbol $b$ from the stack. The transition function then sends the pushdown automaton to a state $r_{i+1}$ and pushes the symbol $b'$ to the stack.

Indeed, the second condition corresponds exactly to having the following transition in the pushdown automaton:
\begin{center}
\begin{tikzpicture}[node distance=3cm, >=latex, every state/.style={fill=white}]
\node[draw=none] (r) {$\dots$};
\node[state, minimum size=1cm] (r0) [right=1cm of r] {$r_{i}$};
\node[state, minimum size=1cm] (r1) [right of=r0] {$r_{i+1}$};
\node[draw=none] (rr) [right=1cm of r1] {$\dots$};

\path[-latex] (r) edge [above] node {} (r0);
\path[-latex] (r0) edge [above] node {$w_{i}, b \mapsto b'$} (r1);
\path[-latex] (r1) edge [above] node {} (rr);
\end{tikzpicture}
\end{center}

\subsection{Language of a Pushdown Automaton}

Pushdown automata recognize languages just as finite automata do, and the set of all input words accepted by a pushdown automaton is referred to as the language of that automaton. We denote the class of languages recognized by a pushdown automaton by \PDA.

\begin{example}
Consider $L_{\texttt{()}}$, our language of balanced parentheses from earlier. Suppose $\Sigma = \{\texttt{(}, \texttt{)}\}$ and $\Gamma = \{\bot, \texttt{P}\}$. A pushdown automaton recognizing this language is as follows:
\begin{center}
\begin{tikzpicture}[node distance=2.5cm, >=latex, every state/.style={fill=white}]
\node[state, initial] (q0) {$q_{0}$};
\node[state] (q1) [right of=q0] {$q_{1}$};
\node[state, accepting] (q2) [right of=q1] {$q_{2}$};

\path[-latex] (q0) edge [above] node {$\epsilon, \epsilon \mapsto \bot$} (q1);
\path[-latex] (q1) edge [loop above] node {$\texttt{(}, \epsilon \mapsto \texttt{P}$} (q1);
\path[-latex] (q1) edge [loop below] node {$\texttt{)}, \texttt{P} \mapsto \epsilon$} (q1);
\path[-latex] (q1) edge [above] node {$\epsilon, \bot \mapsto \epsilon$} (q2);
\end{tikzpicture}
\end{center}
As the transitions show, after pushing the symbol $\bot$ to the stack, the pushdown automaton reads left and right parentheses. Every time a left parenthesis \texttt{(} is read, the pushdown automaton pushes a symbol \texttt{P} to the stack. Likewise, every time a right parenthesis \texttt{)} is read, the pushdown automaton pops a symbol \texttt{P} from the stack to account for some left parenthesis being matched.

Note that, if the input word contains more right parentheses than left parentheses, then the pushdown automaton will not be able to pop a symbol \texttt{P} from the stack. Similarly, if the input word contains more left parentheses than right parentheses, then it will not be able to pop the symbol $\bot$ from the stack. In either case, it becomes stuck in state $q_{1}$ and unable to accept the input word.
\end{example}

\begin{example}
Let $\Sigma = \{\texttt{a}, \texttt{b}, \texttt{c}\}$, and consider the language
\begin{equation*}
L_{\text{twoequal}} = \{\texttt{a}^{i}\texttt{b}^{j}\texttt{c}^{k} \mid i, j, k \geq 0 \text{ and } i = j \text{ or } j = k\}.
\end{equation*}
A pushdown automaton recognizing $L_{\text{twoequal}}$ must have two ``branches": one branch to handle the case where $i = j$, and one branch to handle the case where $j = k$. Since we don't know in advance which branch we will need to take, we can use the nondeterminism inherent in the pushdown automaton model.

A pushdown automaton recognizing this language would therefore look like the following, where the upper branch handles the case $i = j$ and the lower branch handles the case $j = k$:
\begin{center}
\begin{tikzpicture}[node distance=2.5cm, >=latex, every state/.style={fill=white}]
\node[state, initial] (q0) {$q_{0}$};
\node[state] (q1) [above right=0.5cm of q0] {$q_{1}$};
\node[state] (q2) [right of=q1] {$q_{2}$};
\node[state, accepting] (q3) [right of=q2] {$q_{3}$};
\node[state] (q4) [below right=0.5cm of q0] {$q_{4}$};
\node[state] (q5) [right of=q4] {$q_{5}$};
\node[state] (q6) [right of=q5] {$q_{6}$};
\node[state, accepting] (q7) [right of=q6] {$q_{7}$};

\path[-latex] (q0) edge [above left] node {$\epsilon, \epsilon \mapsto \bot$} (q1);
\path[-latex] (q0) edge [below left] node {$\epsilon, \epsilon \mapsto \bot$} (q4);

\path[-latex] (q1) edge [loop above] node {$\texttt{a}, \epsilon \mapsto \texttt{A}$} (q1);
\path[-latex] (q1) edge [above] node {$\epsilon, \epsilon \mapsto \epsilon$} (q2);
\path[-latex] (q2) edge [loop above] node {$\texttt{b}, \texttt{A} \mapsto \epsilon$} (q2);
\path[-latex] (q2) edge [above] node {$\epsilon, \bot \mapsto \epsilon$} (q3);
\path[-latex] (q3) edge [loop above] node {$\texttt{c}, \epsilon \mapsto \epsilon$} (q3);

\path[-latex] (q4) edge [loop below] node {$\texttt{a}, \epsilon \mapsto \epsilon$} (q4);
\path[-latex] (q4) edge [above] node {$\epsilon, \epsilon \mapsto \epsilon$} (q5);
\path[-latex] (q5) edge [loop below] node {$\texttt{b}, \epsilon \mapsto \texttt{B}$} (q5);
\path[-latex] (q5) edge [above] node {$\epsilon, \epsilon \mapsto \epsilon$} (q6);
\path[-latex] (q6) edge [loop below] node {$\texttt{c}, \texttt{B} \mapsto \epsilon$} (q6);
\path[-latex] (q6) edge [above] node {$\epsilon, \bot \mapsto \epsilon$} (q7);
\end{tikzpicture}
\end{center}
\end{example}

%\subsection{Constructing Pushdown Automata}

%\begin{construction}
% I would like to write a short section about how one can design a pushdown automaton for a given language/application/etc.
%\end{construction}