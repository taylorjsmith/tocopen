\section{Equivalence of Models}\label{sec:equivalenceofmodelscontextfree}

\firstwords{You may recall} from our discussion of regular languages that we proved a number of exciting results: deterministic and nondeterministic finite automata are equivalent in terms of recognition power, regardless of whether epsilon transitions are involved, and each of these models is itself equivalent in recognition power to regular expressions. These results allowed us to establish Kleene's theorem, which characterized the class of regular languages in terms of several different models of computation.

Now that we're focusing on context-free languages, and now that we have two ways of representing context-free languages---namely, context-free grammars and pushdown automata---it would be nice to establish a connection between the two representations. This brings us to yet another exciting result, which will be the focus of this section. Since the overall proof is quite lengthy, we will split the proof of the main result into two parts.

\subsection{$\CFG \Rightarrow \PDA$}

For the first half of our main result, we will show that we can convert any context-free grammar into a pushdown automaton recognizing the language generated by the grammar. Specifically, given a context-free grammar $G$, we will construct a pushdown automaton $\mathcal{M}$ that functions as a \emph{top-down parser} on its input word $w$; that is, beginning with the start nonterminal $S$, $\mathcal{M}$ will repeatedly apply rules from $R$ to check whether $w$ can be generated via a leftmost derivation. If so, then $\mathcal{M}$ will accept $w$.

\begin{remark}
We could alternatively construct $\mathcal{M}$ to act as a \emph{bottom-up parser}, where it applies rules backward starting from the input word $w$ to see if the start nonterminal $S$ can be reached. The outcome is the same, though, so we will not discuss this alternative construction here.
\end{remark}

Note that, for the purposes of this proof, we will ``condense" multiple transitions of our pushdown automaton into one transition; that is, if we have some sequence of transitions
\begin{center}
\begin{tikzpicture}[node distance=2.75cm, >=latex, every state/.style={fill=white}]
\node[state] (qi) {$q_{i}$};
\node[state] (q1) [right of=qi] {};
\node[state] (q2) [right of=q1] {};
\node[state] (qj) [right of=q2] {$q_{j}$};

\path[-latex] (qi) edge [above] node {$x, A \mapsto B$} (q1);
\path[-latex] (q1) edge [above] node {$\epsilon, \epsilon \mapsto C$} (q2);
\path[-latex] (q2) edge [above] node {$\epsilon, \epsilon \mapsto D$} (qj);
\end{tikzpicture}
\end{center}
then we will depict this sequence of transitions as one single transition of the form
\begin{center}
\begin{tikzpicture}[node distance=3.25cm, >=latex, every state/.style={fill=white}]
\node[state] (qi) {$q_{i}$};
\node[state] (qj) [right of=qi] {$q_{j}$};

\path[-latex] (qi) edge [above] node {$x, A \mapsto BCD$} (qj);
\end{tikzpicture}
\end{center}
and we replace the symbol $A$ on the stack with the symbols $BCD$, in that order from bottom to top.

\begin{lemma}\label{lem:CFGtoPDA}
Given a context-free grammar $G$ generating a language $L(G)$, there exists a pushdown automaton $\mathcal{M}$ such that $L(\mathcal{M}) = L(G)$.

\begin{proof}
Suppose we are given a context-free grammar $G = (V, \Sigma_{G}, R, S)$. We construct a pushdown automaton $\mathcal{M} = (Q, \Sigma, \Gamma, \delta, q_{0}, F)$ that recognizes the language generated by $G$ in the following way:
\begin{itemize}
\item The set of states is $Q = \{q_{S}, q_{R}\}$. The first state, $q_{S}$, corresponds to the point during the computation at which the context-free grammar $G$ begins to generate the word. The second state, $q_{R}$, corresponds to the remainder of the computation where $G$ applies rules from its rule set.
\item The input alphabet is $\Sigma = \Sigma_{G}$. If $\mathcal{M}$ accepts its input word, then the word could be generated by $G$, and therefore it must consist of terminal symbols.
\item The stack alphabet is $\Gamma = V \cup \Sigma_{G}$. We will use the stack of $\mathcal{M}$ to keep track of where we are in the leftmost derivation of the word.
\item The initial state is $q_{0} = q_{S}$.
\item The final state is $F = \{q_{R}\}$.
\item The transition function $\delta$ consists of three types of transitions:
	\begin{enumerate}
	\item \textbf{Initial transition}: $\delta(q_{S}, \epsilon, \epsilon) = \{(q_{R}, S)\}$. This transition initializes the stack by pushing to it the start nonterminal $S$, and then moves to the state $q_{R}$ for the remainder of the computation.
	
	\item \textbf{Nonterminal transition}: $\delta(q_{R}, \epsilon, A) = \{(q_{R}, \alpha_{n}\dots\alpha_{2}\alpha_{1})\}$ for each rule of the form $A \rightarrow \alpha_{1}\alpha_{2}\dots\alpha_{n}$, where $A \in V$ and $\alpha_{i} \in V \cup \Sigma_{G}$ for all $i$. Transitions of this form simulate the application of a given rule by popping the left-hand side ($A$) from the stack and pushing the right-hand side ($\alpha_{1}\alpha_{2}\dots\alpha_{n}$) to the stack in its place in reverse order. Pushing the symbols in reverse ensures that the next symbol we need to read ($\alpha_{1}$) is at the top of the stack.
	
	Note that if $n = 0$, then the transition will be of the form $\delta(q_{R}, \epsilon, A) = \{(q_{R}, \epsilon)\}$.
	
	\item \textbf{Terminal transition}: $\delta(q_{R}, c, c) = \{(q_{R}, \epsilon)\}$ for each terminal symbol $c \in \Sigma_{G}$. Transitions of this form compare a terminal symbol on the stack to the current input word symbol. If the two symbols match, then the computation continues.
	\end{enumerate}
\end{itemize}
During the computation, after the initial transition is followed, $\mathcal{M}$ follows either nonterminal transitions or terminal transitions until its stack is empty or it runs out of input word symbols. If a nonterminal symbol $A$ is at the top of the stack, $\mathcal{M}$ nondeterministically chooses one of the rules for $A$ and follows the corresponding transition. If a terminal symbol $c$ is at the top of the stack, $\mathcal{M}$ performs the comparison between input and stack symbol as described earlier.

By this construction, we can see that $\mathcal{M}$ finishes its computation with an empty stack and no input word symbols of $w$ left to read whenever $S \Rightarrow^{*} w$, and so $\mathcal{M}$ accepts the input word $w$ if $w$ can be generated by the context-free grammar $G$. Therefore, $L(\mathcal{M}) = L(G)$ as desired.
\end{proof}
\end{lemma}

Visually, we can think of the pushdown automaton constructed in the proof of Lemma~\ref{lem:CFGtoPDA} in the following way, where the number of each transition corresponds to its type:
\begin{center}
\begin{tikzpicture}[node distance=2.75cm, >=latex, every state/.style={fill=white}]
\node[state, initial] (qs) {$q_{S}$};
\node[state, accepting] (qr) [right of=qs] {$q_{R}$};

\path[-latex] (qs) edge [above] node {1.\ $\epsilon, \epsilon \mapsto S$} (qr);
\path[-latex] (qr) edge [loop right, align=left] node {2.\ $\epsilon, A \mapsto \alpha_{n}\dots\alpha_{2}\alpha_{1}$ \\ 2.\ $\epsilon, A \mapsto \epsilon$ \\ 3.\ $c, c \mapsto \epsilon$} (qr);
\end{tikzpicture}
\end{center}

Note that we don't require the symbol $\bot$ here, since we're only using the stack to keep track of where we are in the grammar's derivation.

\begin{example}
Consider the following context-free grammar $G$, where $V = \{S, A\}$ and $\Sigma_{G} = \{\texttt{0}, \texttt{1}, \texttt{\#}\}$:
\begin{align*}
S	&\rightarrow	\texttt{0}S\texttt{1} \mid A \\
A	&\rightarrow	\texttt{\#}
\end{align*}
This grammar generates words of the form $\texttt{0}^{n}\texttt{\#}\texttt{1}^{n}$, where $n \geq 0$.

We convert the context-free grammar $G$ to a pushdown automaton $\mathcal{M}$. Take $Q = \{q_{S}, q_{R}\}$, $\Sigma = \Sigma_{G}$, $\Gamma = V \cup \Sigma_{G}$, $q_{0} = q_{S}$, and $F = \{q_{R}\}$. Finally, add the following transitions to $\delta$:
\begin{itemize}
\item $\delta(q_{S}, \epsilon, \epsilon) = \{(q_{R}, S)\}$. This initial transition pushes the start nonterminal $S$ to the stack.
\item $\delta(q_{R}, \epsilon, S) = \{(q_{R}, \texttt{1}S\texttt{0}), (q_{R}, A)\}$. These nonterminal transitions account for the $S$ rules.
\item $\delta(q_{R}, \epsilon, A) = \{(q_{R}, \texttt{\#})\}$. This nonterminal transition accounts for the $A$ rule.
\item $\delta(q_{R}, \texttt{0}, \texttt{0}) = \{(q_{R}, \epsilon)\}$, $\delta(q_{R}, \texttt{1}, \texttt{1}) = \{(q_{R}, \epsilon)\}$, and $\delta(q_{R}, \texttt{\#}, \texttt{\#}) = \{(q_{R}, \epsilon)\}$. These terminal transitions match the terminal symbols on the stack to the input word symbols.
\end{itemize}
This pushdown automaton $\mathcal{M}$ looks like the following:
\begin{center}
\begin{tikzpicture}[node distance=2.75cm, baseline=(current bounding box.center), >=latex, every state/.style={fill=white}]
\node[state, initial] (qs) {$q_{S}$};
\node[state, accepting] (qr) [right of=qs] {$q_{R}$};

\path[-latex] (qs) edge [above] node {$\epsilon, \epsilon \mapsto S$} (qr);
\path[-latex] (qr) edge [loop right] node[align=left] {$\epsilon, S \mapsto \texttt{1}S\texttt{0} \quad \texttt{0}, \texttt{0} \mapsto \epsilon$ \\ $\epsilon, S \mapsto A \quad\quad \texttt{1}, \texttt{1} \mapsto \epsilon$ \\ $\epsilon, A \mapsto \texttt{\#} \quad\quad\, \texttt{\#}, \texttt{\#} \mapsto \epsilon$} (qr);
\end{tikzpicture}
\end{center}

As an illustration of the computation of $\mathcal{M}$, let's look at the stack as $\mathcal{M}$ reads an example input word \texttt{00\#11}. We can see that $G$ generates this word by the derivation $S \Rightarrow \texttt{0}S\texttt{1} \Rightarrow \texttt{00}S\texttt{11} \Rightarrow \texttt{00}A\texttt{11} \Rightarrow \texttt{00\#11}$.
\begin{center}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,white,white,white}, draw, anchor=center}]
\node[stack=4] (S) {
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {\texttt{00\#11}};
\end{tikzpicture}
\hspace{0.1cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,white,white,\fourthcolour}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}{\color{\maincolour}$S$}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {\texttt{00\#11}};
\end{tikzpicture}
\hspace{0.1cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,\fourthcolour,white,white}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}\texttt{1}
\nodepart{three}$S$
\nodepart{two}{\color{\maincolour}\texttt{0}}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {\texttt{00\#11}};
\end{tikzpicture}
\hspace{0.1cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,white,\fourthcolour,white}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}\texttt{1}
\nodepart{three}{\color{\maincolour}$S$}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {{\color{\neutralcolour}\cancel{\texttt{0}}}\texttt{0\#11}};
\end{tikzpicture}
\hspace{0.1cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={\fourthcolour,white,white,white}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}\texttt{1}
\nodepart{three}\texttt{1}
\nodepart{two}$S$
\nodepart{one}{\color{\maincolour}\texttt{0}}
};
\draw[thick, color=\fourthcolour] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {{\color{\neutralcolour}\cancel{\texttt{0}}}\texttt{0\#11}};
\end{tikzpicture}
\hspace{0.1cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,\fourthcolour,white,white}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}\texttt{1}
\nodepart{three}\texttt{1}
\nodepart{two}{\color{\maincolour}$S$}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {{\color{\neutralcolour}\cancel{\texttt{0}}}{\color{\neutralcolour}\cancel{\texttt{0}}}\texttt{\#11}};
\end{tikzpicture}

\medskip

\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,\fourthcolour,white,white}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}\texttt{1}
\nodepart{three}\texttt{1}
\nodepart{two}{\color{\maincolour}$A$}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {{\color{\neutralcolour}\cancel{\texttt{0}}}{\color{\neutralcolour}\cancel{\texttt{0}}}\texttt{\#11}};
\end{tikzpicture}
\hspace{0.1cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,\fourthcolour,white,white}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}\texttt{1}
\nodepart{three}\texttt{1}
\nodepart{two}{\color{\maincolour}\texttt{\#}}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {{\color{\neutralcolour}\cancel{\texttt{0}}}{\color{\neutralcolour}\cancel{\texttt{0}}}\texttt{\#11}};
\end{tikzpicture}
\hspace{0.1cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,white,\fourthcolour,white}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}\texttt{1}
\nodepart{three}{\color{\maincolour}\texttt{1}}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {{\color{\neutralcolour}\cancel{\texttt{0}}}{\color{\neutralcolour}\cancel{\texttt{0}}}{\color{\neutralcolour}\cancel{\texttt{\#}}}\texttt{11}};
\end{tikzpicture}
\hspace{0.1cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,white,white,\fourthcolour}, draw, anchor=center}]
\node[stack=4] (S) {
\nodepart{four}{\color{\maincolour}\texttt{1}}
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {{\color{\neutralcolour}\cancel{\texttt{0}}}{\color{\neutralcolour}\cancel{\texttt{0}}}{\color{\neutralcolour}\cancel{\texttt{\#}}}{\color{\neutralcolour}\cancel{\texttt{1}}}\texttt{1}};
\end{tikzpicture}
\hspace{0.1cm}
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1, rectangle split part fill={white,white,white,white}, draw, anchor=center}]
\node[stack=4] (S) {
};
\draw[thick, color=white] (S.north west) -- (S.north east);
\node[yshift=-1.25cm] {{\color{\neutralcolour}\cancel{\texttt{0}}}{\color{\neutralcolour}\cancel{\texttt{0}}}{\color{\neutralcolour}\cancel{\texttt{\#}}}{\color{\neutralcolour}\cancel{\texttt{1}}}{\color{\neutralcolour}\cancel{\texttt{1}}}};
\end{tikzpicture}
\end{center}
\end{example}

\subsection{$\PDA \Rightarrow \CFG$}

Now, we consider the other half of our main result. In order to convert a pushdown automaton to a context-free grammar, we must first ensure the pushdown automaton has certain properties: namely, the pushdown automaton must have a single accepting state, it must empty its stack before accepting, and each transition of the pushdown automaton must either push to or pop from the stack, but not both simultaneously. Let us refer to a pushdown automaton with these properties as a \emph{simplified pushdown automaton}.

Fortunately, it's easy to convert from a pushdown automaton to a simplified pushdown automaton.

\begin{colouredbox}
\begin{itemize}
\item To ensure the pushdown automaton has a single accepting state, we make each original accepting state non-accepting and add epsilon transitions from those states to a new single accepting state.
\begin{center}
\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.center), >=latex, every state/.style={fill=white}]
\node[state, accepting, inner sep=1pt, minimum size=1.5em] (q1) {};
\node[state, accepting, inner sep=1pt, minimum size=1.5em] [below right=1cm of q1] (q2) {};
\node[state, accepting, inner sep=1pt, minimum size=1.5em] [above right=1cm of q1] (q3) {};
\end{tikzpicture}
\hspace{0.25cm}
$\Longrightarrow$
\hspace{0.5cm}
\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.center), >=latex, every state/.style={fill=white}]
\node[state, inner sep=1pt, minimum size=1.5em] (q1) {};
\node[state, inner sep=1pt, minimum size=1.5em] [below right=1cm of q1] (q2) {};
\node[state, inner sep=1pt, minimum size=1.5em] [above right=1cm of q1] (q3) {};
\node[state, accepting, inner sep=1pt, minimum size=1.5em] [right=1.66cm of q1] (qa) {};

\path[-latex] (q1) edge [above, pos=0.45] node {$\epsilon, \epsilon \mapsto \epsilon$} (qa);
\path[-latex] (q2) edge [below right] node {$\epsilon, \epsilon \mapsto \epsilon$} (qa);
\path[-latex] (q3) edge [above right] node {$\epsilon, \epsilon \mapsto \epsilon$} (qa);
\end{tikzpicture}
\end{center}

\item To ensure the pushdown automaton empties its stack before accepting, we add a state immediately before the accepting state that removes all symbols from the stack.
\begin{center}
\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.center), >=latex, every state/.style={fill=white}]
\node[state, accepting, inner sep=1pt, minimum size=1.5em] (q1) {};
\end{tikzpicture}
\hspace{0.5cm}
$\Longrightarrow$
\hspace{-0.25cm}
\begin{tikzpicture}[node distance=2.75cm, baseline={([yshift=-0.6cm]current bounding box.center)}, >=latex, every state/.style={fill=white}]
\node[state, inner sep=1pt, minimum size=1.5em] (q0) {};
\node[state, accepting, inner sep=1pt, minimum size=1.5em] (q1) [right=1.75cm of q0] {};

\path[-latex] (q0) edge [loop above] node[align=center, font={\small}] {$\epsilon, A \mapsto \epsilon$ \\ for each $A \in \Gamma$} (q0);
\path[-latex] (q0) edge [above] node {$\epsilon, \epsilon \mapsto \epsilon$} (q1);
\end{tikzpicture}
\end{center}

\item To ensure that each transition of the pushdown automaton either pushes to or pops from the stack, but not both, we split each transition that both pushes and pops into two separate transitions.
\begin{center}
\begin{tikzpicture}[node distance=2.75cm, baseline=(current bounding box.center), >=latex, every state/.style={fill=white}]
\node[state, inner sep=1pt, minimum size=1.5em] (q1) {};
\node[state, inner sep=1pt, minimum size=1.5em] (q2) [right=1.75cm of q1] {};

\path[-latex] (q1) edge [above] node {$x, A \mapsto B$} (q2);
\end{tikzpicture}
\hspace{0.25cm}
$\Longrightarrow$
\hspace{0.25cm}
\begin{tikzpicture}[node distance=2.75cm, baseline=(current bounding box.center), >=latex, every state/.style={fill=white}]
\node[state, inner sep=1pt, minimum size=1.5em] (q1) {};
\node[state, inner sep=1pt, minimum size=1.5em] (qa) [right=1.75cm of q1] {};
\node[state, inner sep=1pt, minimum size=1.5em] (q2) [right=1.75cm of qa] {};

\path[-latex] (q1) edge [above] node {$x, A \mapsto \epsilon$} (qa);
\path[-latex] (qa) edge [above] node {$\epsilon, \epsilon \mapsto B$} (q2);
\end{tikzpicture}
\end{center}

Additionally, if we have an epsilon transition that neither pushes nor pops, then we replace it with two ``dummy" transitions that push and then immediately pop the same stack symbol.
\begin{center}
\begin{tikzpicture}[node distance=2.75cm, baseline=(current bounding box.center), >=latex, every state/.style={fill=white}]
\node[state, inner sep=1pt, minimum size=1.5em] (q1) {};
\node[state, inner sep=1pt, minimum size=1.5em] (q2) [right=1.75cm of q1] {};

\path[-latex] (q1) edge [above] node {$x, \epsilon \mapsto \epsilon$} (q2);
\end{tikzpicture}
\hspace{0.25cm}
$\Longrightarrow$
\hspace{0.25cm}
\begin{tikzpicture}[node distance=2.75cm, baseline=(current bounding box.center), >=latex, every state/.style={fill=white}]
\node[state, inner sep=1pt, minimum size=1.5em] (q1) {};
\node[state, inner sep=1pt, minimum size=1.5em] (qa) [right=1.75cm of q1] {};
\node[state, inner sep=1pt, minimum size=1.5em] (q2) [right=1.75cm of qa] {};

\path[-latex] (q1) edge [above] node {$x, \epsilon \mapsto A$} (qa);
\path[-latex] (qa) edge [above] node {$\epsilon, A \mapsto \epsilon$} (q2);
\end{tikzpicture}
\end{center}
\end{itemize}
\end{colouredbox}

With a simplified pushdown automaton, we can now perform the conversion to a context-free grammar.

\begin{lemma}\label{lem:PDAtoCFG}
Given a simplified pushdown automaton $\mathcal{M}$ recognizing a language $L(\mathcal{M})$, there exists a context-free grammar $G$ such that $L(G) = L(\mathcal{M})$.

\begin{proof}
Suppose we are given a simplified pushdown automaton $\mathcal{M} = (Q, \Sigma, \Gamma, \delta, q_{0}, q_{\text{accept}})$. We will construct a context-free grammar $G = (V, \Sigma_{G}, R, S)$ that generates the language recognized by $\mathcal{M}$.

For each pair of states $p$ and $q$ in $\mathcal{M}$, our grammar will include a rule $A_{pq}$ that simulates the computation of $\mathcal{M}$ starting in state $p$ with some stack contents and ending in state $q$ with the same stack contents. (Note that the stack may be manipulated during this computation; we just ensure that the contents of the stack are the same at the beginning and the end.)

We construct $G$ in the following way:
\begin{itemize}
\item The set of nonterminal symbols is $V = \{A_{pq} \mid p, q, \in Q\}$.
\item The set of terminal symbols is $\Sigma_{G} = \Sigma$.
\item The start nonterminal is $S = A_{q_{0} q_{\text{accept}}}$ (i.e., the rule corresponding to the computation starting in state $q_{0}$ and ending in state $q_{\text{accept}}$).
\item The set of rules $R$ consists of three types of rules:
	\begin{enumerate}
	\item For each state $q \in Q$, add the rule $A_{qq} \rightarrow \epsilon$ to $R$.
	\begin{center}
	\begin{tikzpicture}[node distance=1.5cm, >=latex, every state/.style={fill=white}]
	\node[state, inner sep=1pt, minimum size=1.5em] (q) {$q$};
	\end{tikzpicture}
	\end{center}
	
	\item For each triplet of states $p, q, r \in Q$, add the rule $A_{pr} \rightarrow A_{pq}A_{qr}$ to $R$.
	\begin{center}
	\begin{tikzpicture}[node distance=1.5cm, >=latex, every state/.style={fill=white}, decoration={%
	snake,
	segment length=2mm,
	amplitude=0.4mm,
	pre length=4pt,
	post length=4pt,
	}]
	\node[state, inner sep=1pt, minimum size=1.5em] (p) {$p$};
	\node[state, inner sep=1pt, minimum size=1.5em] (q) [right of=p] {$q$};
	\node[state, inner sep=1pt, minimum size=1.5em] (r) [right of=q] {$r$};
	
	\path[-latex, draw=black, decorate] (p) -- (q);
	\path[-latex, draw=black, decorate] (q) -- (r);
	\end{tikzpicture}
	\end{center}
	
	\item For each quadruplet of states $p, q, r, s \in Q$, input symbols $\texttt{a}, \texttt{b} \in \Sigma \cup \{\epsilon\}$, and stack symbol $\texttt{T} \in \Gamma$, if $(q, \texttt{T}) \in \delta(p, \texttt{a}, \epsilon)$ and $(s, \epsilon) \in \delta(r, \texttt{b}, \texttt{T})$, then add the rule $A_{ps} \rightarrow \texttt{a}A_{qr}\texttt{b}$ to $R$.
	\begin{center}
	\begin{tikzpicture}[node distance=1.5cm, >=latex, every state/.style={fill=white}, decoration={%
	snake,
	segment length=2mm,
	amplitude=0.4mm,
	pre length=4pt,
	post length=4pt,
	}]
	\node[state, inner sep=1pt, minimum size=1.5em] (p) {$p$};
	\node[state, inner sep=1pt, minimum size=1.5em] (q) [right=2cm of p] {$q$};
	\node[state, inner sep=1pt, minimum size=1.5em] (r) [below of=p] {$r$};
	\node[state, inner sep=1pt, minimum size=1.5em] (s) [right=2cm of r] {$s$};
	
	\path[-latex] (p) edge [above] node {$\texttt{a}, \epsilon \mapsto \texttt{T}$} (q);
	\path[-latex, draw=black, decorate] (q) -- (r);
	\path[-latex] (r) edge [below] node {$\texttt{b}, \texttt{T} \mapsto \epsilon$} (s);
	\end{tikzpicture}
	\end{center}
	\end{enumerate}
\end{itemize}

The first type of rule is a ``dummy" rule that essentially corresponds to staying in the state $q$ and adding nothing to the derivation. The second type of rule breaks down the overall computation into smaller components, taking into account intermediate states. Finally, the third type of rule adds terminal symbols to the derivation depending on the components of the overall computation.

With these rules, we can establish that the rule $A_{q_{0}q_{\text{accept}}}$ generates a word $w$ if and only if, starting in the state $q_{0}$ with an empty stack, the computation of $\mathcal{M}$ on $w$ ends in the state $q_{\text{accept}}$ also with an empty stack. Therefore, $w$ is generated by the context-free grammar $G$ if $\mathcal{M}$ accepts $w$, and $L(G) = L(\mathcal{M})$ as desired.
\end{proof}
\end{lemma}

\begin{example}
Consider the following simplified pushdown automaton $\mathcal{M}$, where $\Sigma = \{\texttt{0}, \texttt{1}\}$ and $\Gamma = \{\texttt{X}, \texttt{Y}\}$:
\begin{center}
\begin{tikzpicture}[node distance=2.75cm, baseline=(current bounding box.center), >=latex, every state/.style={fill=white}]
\node[state, initial] (q0) {$q_{0}$};
\node[state] (q1) [right of=q0] {$q_{1}$};
\node[state] (q2) [below right=1cm of q1] {$q_{2}$};
\node[state] (q3) [below of=q1] {$q_{3}$};
\node[state, accepting] (q4) [left of=q3] {$q_{4}$};

\path[-latex] (q0) edge [above] node {$\epsilon, \epsilon \mapsto \bot$} (q1);
\path[-latex] (q1) edge [loop above] node[align=center] {$\texttt{0}, \epsilon \mapsto \texttt{X}$ \\ $\texttt{1}, \epsilon \mapsto \texttt{Y}$} (q1);
\path[-latex] (q1) edge [above right] node {$\epsilon, \epsilon \mapsto \texttt{X}$} (q2);
\path[-latex] (q2) edge [below right] node {$\epsilon, \texttt{X} \mapsto \epsilon$} (q3);
\path[-latex] (q3) edge [loop below] node[align=center] {$\texttt{0}, \texttt{Y} \mapsto \epsilon$ \\ $\texttt{1}, \texttt{X} \mapsto \epsilon$} (q3);
\path[-latex] (q3) edge [above] node {$\epsilon, \bot \mapsto \epsilon$} (q4);
\end{tikzpicture}
\end{center}
This pushdown automaton recognizes words of the form $w \cdot \overline{w}^{\text{R}}$, where $\overline{w}$ is $w$ with \texttt{0}s and \texttt{1}s swapped.

We convert the pushdown automaton $\mathcal{M}$ to a context-free grammar $G$. Let $V = \{A_{00}, A_{01}, A_{02}, A_{03}, A_{04}, A_{11}, A_{12}, A_{13}, A_{14}, A_{22}, A_{23}, A_{24}, \allowbreak A_{33}, A_{34}, A_{44}\}$ and take $\Sigma_{G} = \Sigma$. We also take $S = A_{04}$, since $q_{0}$ is the initial state and $q_{4}$ is the accepting state of $\mathcal{M}$. Finally, we add the following rules to the rule set $R$:
\begin{itemize}
\item Type 1 rules: 
$A_{00} \rightarrow \epsilon$, 
$A_{11} \rightarrow \epsilon$, 
$A_{22} \rightarrow \epsilon$,  
$A_{33} \rightarrow \epsilon$, and 
$A_{44} \rightarrow \epsilon$.
\item Type 2 rules: 
\begin{align*}
A_{01} &\rightarrow A_{00}A_{01} \mid A_{01}A_{11} \\
A_{02} &\rightarrow A_{00}A_{02} \mid  A_{01}A_{12} \mid A_{02}A_{22} \\
A_{03} &\rightarrow A_{00}A_{03} \mid A_{01}A_{13} \mid A_{02}A_{23} \mid A_{03}A_{33} \\
A_{04} &\rightarrow A_{00}A_{04} \mid A_{01}A_{14} \mid A_{02}A_{24} \mid A_{03}A_{34} \mid A_{04}A_{44} \\
A_{12} &\rightarrow A_{11}A_{12} \mid A_{12}A_{22} \\
A_{13} &\rightarrow A_{11}A_{13} \mid A_{12}A_{23} \mid A_{13}A_{33} \\
A_{14} &\rightarrow A_{11}A_{14} \mid A_{12}A_{24} \mid A_{13}A_{34} \mid A_{14}A_{44} \\
A_{23} &\rightarrow A_{22}A_{23} \mid A_{23}A_{33} \\
A_{24} &\rightarrow A_{22}A_{24} \mid A_{23}A_{34} \mid A_{24}A_{44} \\
A_{34} &\rightarrow A_{33}A_{34} \mid A_{34}A_{44}
\end{align*}
\item Type 3 rules: 
\begin{align*}
A_{13} &\rightarrow \texttt{0}A_{13}\texttt{1} \mid \texttt{1}A_{13}\texttt{0} \mid \epsilon A_{22} \epsilon \text{ (or just } A_{22} \text{)} \\
A_{04} &\rightarrow \epsilon A_{13} \epsilon \text{ (or just } A_{13} \text{)}
\end{align*}
\end{itemize}

As an illustration, let's see how $G$ derives an example input word \texttt{001011}. Beginning from the start nonterminal $A_{q_{0}q_{\text{accept}}} = A_{04}$, the derivation proceeds in the following way:
\begin{align*}
A_{04} &\Rightarrow \highlightmath{A_{13}} \\
&\Rightarrow \highlightmath{\texttt{0}A_{13}\texttt{1}} \\
&\Rightarrow \texttt{0}\highlightmath{\texttt{0}A_{13}\texttt{1}}\texttt{1} \\
&\Rightarrow \texttt{00}\highlightmath{\texttt{1}A_{13}\texttt{0}}\texttt{11} \\
&\Rightarrow \texttt{001}\highlightmath{A_{22}}\texttt{011} \\
&\Rightarrow \texttt{001}\highlightmath{\epsilon}\texttt{011} = \texttt{001011}.
\end{align*}
\end{example}

\subsection{$\CFG = \PDA$}

Since we know by Definition~\ref{def:contextfreelanguage} that a language is context-free if there exists a context-free grammar generating the language, we can combine the previous two lemmas to get the main result of this section.

\begin{theorem}\label{thm:CFGPDAequivalence}
A language $C$ is context-free if it satisfies any of the following equivalent properties:
\begin{enumerate}
\item There exists a context-free grammar $G$ such that $L(G) = C$; or
\item There exists a pushdown automaton $\mathcal{M}$ such that $L(\mathcal{M}) = C$.
\end{enumerate}
\end{theorem}

We can think of this result as the final piece to obtain the context-free analogue of Kleene's theorem for the regular languages. Since context-free grammars generate context-free languages, and since context-free grammars can be converted to pushdown automata and vice versa, both models correspond to the exact same language class. Unfortunately, this result doesn't get a nice name like Kleene's theorem did, but perhaps the lack of a name is justified when you consider the diagram we get isn't as interesting as the one we had for the regular languages:

\begin{center}
\begin{tikzpicture}
\node (cfg) at (0,0) {\CFG};
\node (pda) at (3,0) {\PDA};

\draw[latex-latex] (cfg) -- (pda);
\end{tikzpicture}
\end{center}

\noindent
(Not exactly a \textit{Scutum Fidei} as before, but maybe a \textit{Gladius Fidei}?)

We're not yet finished, though. Thanks to the equivalence between context-free grammars and pushdown automata, we can establish an important result that relates the class of context-free languages to the class of regular languages.

\begin{theorem}\label{thm:regulariscontextfree}
Every regular language is also a context-free language.

\begin{proof}
Every regular language is recognized by some finite automaton. Since a finite automaton is a pushdown automaton that does not use the stack, every regular language is also recognized by some pushdown automaton. Furthermore, by Theorem~\ref{thm:CFGPDAequivalence}, every regular language is generated by some context-free grammar. Therefore, every regular language is context-free.
\end{proof}
\end{theorem}

Of course, we already know that there exist some context-free languages that are not regular, so this inclusion only works in one direction.
